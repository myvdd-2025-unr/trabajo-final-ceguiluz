---
title: "Trabajo Final – Rendimiento del Centro"
author: "Camila Eguiluz"
format:
  html:
    embed-resources: true
    toc: true
    number-sections: true
    code-fold: show        # botón para mostrar/ocultar código para mejor lectura
    code-summary: "Mostrar código" #para mostrar u ocultar todos los códigos 
    code-tools: true       
execute:
  echo: true               
  warning: false
  message: false
execute-dir: project
---

# Introducción

Este informe utiliza exclusivamente **dos columnas** del archivo `datos.xlsx` para clasificar las visitas:\
- **Clase de Visita**: valores esperados *Screening* y *Randomización*.\
- **Tipo de Visita**: se usa solo para detectar *Screen Failure*.\
- Evaluar el rendimiento del **Instituto de Investigación Clínicas**.\
- Los datos fueron *anonimizados* para proteger la confidencialidad.

Se generan gráficos mensuales y resúmenes por Médico Estudio y Derivantes.\
Todas las figuras se guardan en figs/ como PNG y se incrustan en el reporte.\
En HTML, los gráficos son interactivos con hover (plotly).

# Preparación de datos y lectura de archivos

```{r}
suppressPackageStartupMessages({
  library(readxl); library(dplyr); library(lubridate)
  library(ggplot2); library(tidyr); library(knitr); library(forcats)
})

if (!dir.exists("figs")) dir.create("figs", showWarnings = FALSE)

stopifnot(file.exists("datos.xlsx"))
df <- read_excel("datos.xlsx")

stopifnot("Fecha del Turno" %in% names(df))
stopifnot(all(c("Clase de Visita","Tipo de Visita") %in% names(df)))

df <- df |>
  mutate(
    Mes = floor_date(as.Date(`Fecha del Turno`), "month"),
    Visita = dplyr::case_when(
      `Clase de Visita` == "Screening" ~ "Screening",
      `Clase de Visita` == "Randomización" ~ "Randomización",
      grepl("screen\\s*failure", `Tipo de Visita`, ignore.case = TRUE) ~ "Screen Failure",
      TRUE ~ NA_character_
    )
  ) |>
  filter(!is.na(Visita))

pal <- c("Screening" = "#2E86AB",
         "Randomización" = "#008000",
         "Screen Failure" = "#C73E1D")

# Últimos 3 meses según el dato más reciente
.max_mes <- max(df$Mes, na.rm = TRUE)
.desde   <- floor_date(.max_mes, "month") %m-% months(2)

# Guarda PNG e incrusta.
guardar_y_incrustar <- function(p, archivo, w = 10, h = 5, dpi = 300){
  ruta <- file.path("figs", archivo)
  ggsave(ruta, p, width = w, height = h, dpi = dpi)
  knitr::include_graphics(ruta)
  print(p)
}

```

# Resultados

## Centro — por mes

```{r}
centro_mensual <- df |>
  filter(Mes >= .desde, Mes <= .max_mes) |>
  count(Mes, Visita, name = "Cantidad")

plot_tipo <- function(tabla, tipo, archivo){
  tab <- tabla |> filter(Visita == tipo)
  p <- ggplot(tab, aes(x = Mes, y = Cantidad)) +
    geom_col(fill = pal[[tipo]], width = 15) +
    geom_text(aes(label = Cantidad), vjust = -0.25, size = 3.5) +
    scale_y_continuous(expand = expansion(mult = c(0, 0.08))) +
    scale_x_date(date_labels = "%b %Y", date_breaks = "1 month") +
    labs(title = paste0(tipo, " por mes (últimos 3 meses)"),
         x = "Mes", y = "Cantidad") +
    theme_minimal(base_size = 13)
  guardar_y_incrustar(p, archivo, w = 10, h = 5, dpi = 300)
}

plot_tipo(centro_mensual, "Screening",      "screening_por_mes.png")
plot_tipo(centro_mensual, "Randomización",  "randomizacion_por_mes.png")
plot_tipo(centro_mensual, "Screen Failure", "sf_por_mes.png")

# Totales por tipo de visita (últimos 3 meses)
totales_visita <- df |>
  filter(Mes >= .desde, Mes <= .max_mes) |>
  count(Visita, name = "Total")

knitr::kable(totales_visita,
             caption = "Totales por tipo de visita (últimos 3 meses)")

```

## Rendimiento por Médico del centro 
Para mejor lectura, se elige utilizar menos médicos. Cambiar el n para ver todos

```{r}
# Rendimiento médicos del centro (últimos 3 meses)
if ("Médico Estudio" %in% names(df)) {
  n_top <- 10

  # Conteos por médico y tipo en el período
  counts <- df |>
    filter(!is.na(`Médico Estudio`), Mes >= .desde, Mes <= .max_mes) |>
    count(`Médico Estudio`, Visita, name = "Cantidad")

  # Top N médicos por total de visitas realizadas
  top_ids <- counts |>
    group_by(`Médico Estudio`) |>
    summarise(Total = sum(Cantidad), .groups = "drop") |>
    slice_max(Total, n = n_top, with_ties = FALSE) |>
    pull(`Médico Estudio`)

  # Datos para graficar
  med_plot <- counts |>
    group_by(`Médico Estudio`) |>
    mutate(Total = sum(Cantidad)) |>
    ungroup() |>
    filter(`Médico Estudio` %in% top_ids) |>
    mutate(`Médico Estudio` = forcats::fct_reorder(`Médico Estudio`, Total))

  pd <- position_dodge(width = 0.8)

  p_med_bar <- ggplot(med_plot,
                      aes(x = `Médico Estudio`, y = Cantidad, fill = Visita)) +
    geom_col(position = pd, width = 0.75) +
    geom_text(aes(label = Cantidad),
              position = pd, hjust = -0.15, size = 3) +
    coord_flip() +
    scale_fill_manual(values = pal) +
    scale_y_continuous(expand = expansion(mult = c(0, 0.15))) +
    labs(title = paste0("Médicos del centro Top ", n_top,
                        " (últimos 3 meses)"),
         x = "Médico Estudio", y = "Cantidad", fill = "Tipo") +
    theme_minimal(base_size = 12)

  guardar_y_incrustar(p_med_bar, "medicos_centro.png",
                       w = 10, h = 6, dpi = 300)
} else {
  p0 <- ggplot() + annotate("text", x=0, y=0,
                            label="No está la columna 'Médico Estudio'") +
    theme_void()
  guardar_y_incrustar(p0, "medicos_centro.png", w = 8, h = 5, dpi = 300)
}
```

## Derivantes

```{r}
if ("ID_Derivante" %in% names(df)) {
  deriv <- df |>
    filter(Mes >= .desde, Mes <= .max_mes) |>
    group_by(ID_Derivante) |>
    summarise(
      Enviados     = n(),
      Screening    = sum(Visita == "Screening"),
      Randomizados = sum(Visita == "Randomización"),
      .groups = "drop"
    ) |>
    arrange(desc(Enviados)) |>
    slice_head(n = 10) |>
    pivot_longer(c(Enviados, Screening, Randomizados),
                 names_to = "Métrica", values_to = "Cantidad") |>
    mutate(
      # Orden de las series en la leyenda
      Métrica = factor(Métrica, levels = c("Enviados", "Screening", "Randomizados"))
    )

  pal_der <- c("Enviados"="#5D737E","Screening"="#F18F01","Randomizados"="#008000")
  pd <- position_dodge(width = 0.8)

  p_der <- ggplot(deriv, aes(x = fct_reorder(ID_Derivante, Cantidad),
                             y = Cantidad, fill = Métrica)) +
    geom_col(position = pd, width = 0.75) +
    geom_text(aes(label = Cantidad), position = pd, hjust = -0.15, size = 3) +
    coord_flip() +
    scale_fill_manual(values = pal_der) +
    scale_y_continuous(expand = expansion(mult = c(0, 0.15))) +
    labs(title = "Derivantes Top 10 (últimos 3 meses)",
         x = "ID_Derivante", y = "Cantidad", fill = "Métrica") +
    theme_minimal(base_size = 12)

  guardar_y_incrustar(p_der, "derivantes.png", w = 10, h = 6, dpi = 300)
} else {
  p0 <- ggplot() + annotate("text", x=0, y=0, label="No está la columna 'ID_Derivante'") + theme_void()
  guardar_y_incrustar(p0, "derivantes.png", w = 8, h = 5, dpi = 300)
}
```

# Conclusiones


- En los últimos tres meses, **las visitas de Screening predominaron** (102), seguidas de **Screen Failure** (72) y **Randomización** (57). Esto refleja que existe una tasa alta de pacientes evaluados, aunque no todos logran ingresar a estudios clínicos

- Entre los médicos del centro, se observa una marcada variabilidad: algunos profesionales como **IICDr12 e IICDr06** concentran gran parte de las visitas.

- En cuanto a los **derivantes**, los que más pacientes enviaron fueron **IICDr12, Der69 y Der65**. Igual, no todos esos pacientes llegaron a ingresar a estudios, lo que muestra que todavía hay margen para mejorar en la selección inicial.  

- En general, este análisis me permitió ver **dónde está funcionando mejor el proceso**, algo clave para planificar estrategias futuras de reclutamiento y para optimizar el recorrido de los pacientes dentro del estudio.




# Nota para el informe

::: {.callout-note title="Nota de confidencialidad y limpieza previa" appearance="simple"}
*Desde el archivo original **"1Jan2025 a 27Jul2025.xlsx"** se realizó una limpieza manual para resguardar la confidencialidad.*

*Se eliminaron columnas sensibles que no eran necesarias para el análisis (Estado del Turno, Nro. H.C., Creador por).*

*Se estandarizaron encabezados y formatos (fechas, tildes y espacios).*

*Anonimización automática documentada en el script:*\
- *Pacientes: la columna **“Apellido y Nombre del paciente”** fue reemplazada por identificadores secuenciales: **IICPte##**.*\
- *Médico del centro: se asignó manualmente un ID secuencial a los médicos del centro: **IICDrXX**.*\
- *Médicos derivantes: la columna **“Médico Derivante”** se mutó a **ID_Derivante** conservando **IICDrXX** cuando el derivante pertenece al centro; en caso contrario se asignó **Der##**.*

*El archivo final utilizado en el análisis se guardó como **datos 2024 2025.xlsx** y no contiene nombres propios ni datos sensibles.*
:::

::: {.callout-tip title="Código utilizado para anonimización" collapse="true"}
```{r}
#| eval: false
# ==============================================
# Anonimización de datos 
# ==============================================

normalizar <- function(x) {
  x <- as.character(x); x <- tolower(x)
  x <- gsub("\\s+", " ", x); x <- trimws(x); x
}

# 1) PACIENTES -> IICPte## 
col_pac <- "Apellido y Nombre del Paciente"
if (!(col_pac %in% names(base))) stop("No encuentro la columna: ", col_pac)
pac_raw  <- base[[col_pac]]; pac_norm <- normalizar(pac_raw)
u_pac  <- sort(unique(pac_norm[!is.na(pac_norm) & pac_norm != ""]))
map_pac <- setNames(sprintf("IICPte%02d", seq_along(u_pac)), u_pac)
id_pac <- rep(NA_character_, length(pac_norm))
idx_ok <- which(!is.na(pac_norm) & pac_norm != "")
if (length(idx_ok) > 0) id_pac[idx_ok] <- map_pac[pac_norm[idx_ok]]
base[[col_pac]] <- id_pac

# 2) DERIVANTES -> IICDrXX o Der##
col_der_final  <- "ID_Derivante"; col_der_origen <- "Médico Derivante"
if (col_der_final %in% names(base)) deriv_raw <- base[[col_der_final]]
else if (col_der_origen %in% names(base)) deriv_raw <- base[[col_der_origen]]
else stop("No encuentro ni 'ID_Derivante' ni 'Médico Derivante'.")
deriv_norm <- normalizar(deriv_raw)
es_iic <- grepl("^iicdr[0-9]+$", deriv_norm, TRUE)
es_der <- grepl("^der[0-9]+$",   deriv_norm, TRUE)
cand   <- deriv_norm[!es_iic & !is_der & !is.na(deriv_norm) & deriv_norm != ""]
u_der  <- sort(unique(cand)); map_der <- setNames(sprintf("Der%02d", seq_along(u_der)), u_der)
id_der <- rep(NA_character_, length(deriv_norm))
id_der[es_iic] <- toupper(deriv_norm[es_iic])
id_der[es_der] <- toupper(deriv_norm[es_der])
idx_asig <- which(!es_iic & !is_der & !is.na(deriv_norm) & deriv_norm != "")
if (length(idx_asig) > 0) id_der[idx_asig] <- map_der[deriv_norm[idx_asig]]
base[[col_der_final]] <- id_der
```
:::
